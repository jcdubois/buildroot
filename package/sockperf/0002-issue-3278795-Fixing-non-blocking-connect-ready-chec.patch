From f09e75ef3dd4010f3ce2e823b9a0da25bcd49ec3 Mon Sep 17 00:00:00 2001
From: Alexander Grissik <agrissik@nvidia.com>
Date: Wed, 28 Dec 2022 19:35:27 +0200
Subject: [PATCH 02/33] issue: 3278795 Fixing non-blocking connect ready check

This contains several changes:
1. Changeing default non-blocking connect timeout from 1ms to 5sec.
2. Adding a client parameter to control non-blocking connect timeout: tcp_nb_connect_timeout_ms.
3. Fixing the logic in case non-blocking connect timeout occurs to return an error instead of ignoring it.

Signed-off-by: Alexander Grissik <agrissik@nvidia.com>
---
 src/client.cpp   | 23 ++++++++++++-----------
 src/defs.h       |  2 ++
 src/sockperf.cpp | 25 +++++++++++++++++++++++++
 3 files changed, 39 insertions(+), 11 deletions(-)

diff --git a/src/client.cpp b/src/client.cpp
index f5f71c1..ff98a32 100644
--- a/src/client.cpp
+++ b/src/client.cpp
@@ -817,18 +817,16 @@ static int _connect_check_vma(int ifd) {
 #endif // USING_VMA_EXTRA_API
 
 //------------------------------------------------------------------------------
-static int _connect_check(int ifd) {
-    int rc = SOCKPERF_ERR_NONE;
+static int _connect_check(int ifd, int timeout_ms) {
+    int rc = SOCKPERF_ERR_SOCKET;
     int pollrc;
     bool avail;
 
-#define POLL_TIMEOUT_MS 1
-
 #ifdef __windows__
     fd_set rfds, wfds;
     struct timeval tv;
-    tv.tv_sec = 0;
-    tv.tv_usec = POLL_TIMEOUT_MS * 1000;
+    tv.tv_sec = timeout_ms / 1000;
+    tv.tv_usec = (timeout_ms % 1000) * 1000;
 
     FD_ZERO(&rfds);
     FD_ZERO(&wfds);
@@ -839,12 +837,12 @@ static int _connect_check(int ifd) {
     avail = pollrc > 0 && (FD_ISSET(ifd, &wfds) || FD_ISSET(ifd, &rfds));
 #else
     struct pollfd fds = { .fd = ifd, .events = POLLIN | POLLOUT, };
-    pollrc = poll(&fds, 1, POLL_TIMEOUT_MS);
+    pollrc = poll(&fds, 1, timeout_ms);
     avail = pollrc > 0 && (fds.revents & (POLLIN | POLLOUT));
 #endif /* __windows__ */
 
     if (pollrc < 0) {
-        log_err("Failed to poll for events during connection establishment");
+        log_err("Failed to poll for events during connection establishment. fd=%d", ifd);
     }
     if (avail) {
         socklen_t err_len;
@@ -852,9 +850,12 @@ static int _connect_check(int ifd) {
 
         err_len = sizeof(error);
         if (getsockopt(ifd, SOL_SOCKET, SO_ERROR, &error, &err_len) < 0 || error != 0) {
-            log_err("Can`t connect socket");
-            rc = SOCKPERF_ERR_SOCKET;
+            log_err("Can`t connect socket. fd=%d", ifd);
+        } else {
+            rc = SOCKPERF_ERR_NONE;
         }
+    } else {
+        log_err("Socket connect timeout. fd=%d, timeout_ms=%d.", ifd, timeout_ms);
     }
     return rc;
 }
@@ -931,7 +932,7 @@ int Client<IoType, SwitchDataIntegrity, SwitchActivityInfo, SwitchCycleDuration,
                         } else
 #endif // USING_VMA_EXTRA_API
                         {
-                            rc = _connect_check(ifd);
+                            rc = _connect_check(ifd, s_user_params.tcp_connect_timeout_ms);
                         }
                         if (rc == SOCKPERF_ERR_SOCKET) {
                             break;
diff --git a/src/defs.h b/src/defs.h
index 159e77e..2335e8c 100644
--- a/src/defs.h
+++ b/src/defs.h
@@ -276,6 +276,7 @@ enum {
     OPT_CI_SIG_LVL,               // 45
     OPT_HISTOGRAM,                // 46
     OPT_LOAD_XLIO,                // 47
+    OPT_TCP_NB_CONN_TIMEOUT_MS,   // 48
 #if defined(DEFINED_TLS)
     OPT_TLS
 #endif /* DEFINED_TLS */
@@ -761,6 +762,7 @@ struct user_params_t {
     bool withsock_accl = false;
     int max_looping_over_recv = 1;
     int tos = 0x00;
+    int tcp_connect_timeout_ms = 5000;
     unsigned int lls_usecs = 0;
     bool lls_is_set = false;
     uint32_t dummy_mps = 0;                   // client side only
diff --git a/src/sockperf.cpp b/src/sockperf.cpp
index efd302e..7b1f1a9 100644
--- a/src/sockperf.cpp
+++ b/src/sockperf.cpp
@@ -328,6 +328,9 @@ static const AOPT_DESC client_opt_desc[] = {
       aopt_set_literal(0),
       aopt_set_string("increase_output_precision"),
       "Increase number of digits after decimal point of the throughput output (from 3 to 9). " },
+    { OPT_TCP_NB_CONN_TIMEOUT_MS,                            AOPT_ARG,
+      aopt_set_literal(0),                             aopt_set_string("tcp_nb_connect_timeout_ms"),
+      "Non-blocking connect timeout in milliseconds. Default: 5000." },
     { OPT_DUMMY_SEND, AOPT_OPTARG, aopt_set_literal(0), aopt_set_string("dummy-send"),
       "Use VMA's dummy send API instead of busy wait, must be higher than regular msg rate. "
       "\n\t\t\t\t optional: set dummy-send rate per second (default 10,000), usage: --dummy-send "
@@ -2307,6 +2310,28 @@ static int parse_client_opt(const AOPT_OBJECT *client_obj) {
                 }
             }
         }
+        if (!rc && aopt_check(client_obj, OPT_TCP_NB_CONN_TIMEOUT_MS)) {
+             if (s_user_params.feedfile_name[0] != '\0' || s_user_params.sock_type == SOCK_STREAM) {
+                const char *optarg = aopt_value(client_obj, OPT_TCP_NB_CONN_TIMEOUT_MS);
+                if (optarg) {
+                    errno = 0;
+                    int value = strtol(optarg, NULL, 0);
+                    if (errno != 0 || value < 0) {
+                        log_msg("Invalid TCP connect timeout value %s for --tcp_nb_connect_timeout_ms",
+                                optarg);
+                        rc = SOCKPERF_ERR_BAD_ARGUMENT;
+                    } else {
+                        s_user_params.tcp_connect_timeout_ms = value;
+                    }
+                } else {
+                    log_msg("Invalid TCP connect timeout value for --tcp_nb_connect_timeout_ms");
+                    rc = SOCKPERF_ERR_BAD_ARGUMENT;
+                }
+            } else {
+                log_msg("--tcp_nb_connect_timeout_ms requires --tcp or -f");
+                rc = SOCKPERF_ERR_BAD_ARGUMENT;
+            }
+        }
     }
 
     return rc;
-- 
2.43.0

