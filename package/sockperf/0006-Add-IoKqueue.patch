From 74716ee7a6ff89da6bf8231b40a734da7d868380 Mon Sep 17 00:00:00 2001
From: Wonsup Yoon <pusnow@kaist.ac.kr>
Date: Thu, 23 Feb 2023 23:22:25 +0900
Subject: [PATCH 06/33] Add IoKqueue

---
 src/defs.h         |  4 +++
 src/iohandlers.cpp | 63 +++++++++++++++++++++++++++++++++++++++
 src/iohandlers.h   | 73 ++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 140 insertions(+)

diff --git a/src/defs.h b/src/defs.h
index dd0276c..8b37764 100644
--- a/src/defs.h
+++ b/src/defs.h
@@ -58,6 +58,10 @@ typedef unsigned short int sa_family_t;
 #include <sys/epoll.h>
 #endif
 
+#ifdef __APPLE__
+#include <sys/event.h>
+#endif
+
 #include <stdbool.h>
 #include <stdint.h>
 #include <unordered_map>
diff --git a/src/iohandlers.cpp b/src/iohandlers.cpp
index cf10dcb..2c9a3b2 100644
--- a/src/iohandlers.cpp
+++ b/src/iohandlers.cpp
@@ -251,6 +251,69 @@ int IoEpoll::prepareNetwork() {
     return rc;
 }
 #endif // !defined(__FreeBSD__) && !defined(__APPLE__)
+#if defined(__FreeBSD__) || defined(__APPLE__)
+//==============================================================================
+//------------------------------------------------------------------------------
+IoKqueue::IoKqueue(int _fd_min, int _fd_max, int _fd_num)
+    : IoHandler(_fd_min, _fd_max, _fd_num, 0, 0),
+      m_timeout({g_pApp->m_const_params.select_timeout ? g_pApp->m_const_params.select_timeout->tv_sec : 0,
+                 g_pApp->m_const_params.select_timeout ? g_pApp->m_const_params.select_timeout->tv_usec * 1000 : 0}),
+      mp_timeout(g_pApp->m_const_params.select_timeout ? &m_timeout : NULL) {
+    mp_kqueue_events = NULL;
+    mp_kqueue_changes = NULL;
+    m_max_events = 0;
+}
+
+//------------------------------------------------------------------------------
+IoKqueue::~IoKqueue() {
+    if (mp_kqueue_events) {
+        close(m_kqfd);
+        FREE(mp_kqueue_events);
+        if (mp_kqueue_changes) {
+            FREE(mp_kqueue_changes);
+        }
+    }
+
+}
+
+//------------------------------------------------------------------------------
+int IoKqueue::prepareNetwork() {
+    int rc = SOCKPERF_ERR_NONE;
+
+    int list_count = 0; 
+    mp_kqueue_events = (struct kevent *)MALLOC(MAX_FDS_NUM * sizeof(struct kevent));
+    mp_kqueue_changes = (struct kevent *)MALLOC(MAX_FDS_NUM * sizeof(struct kevent));
+    if (!mp_kqueue_events) {
+        log_err("Failed to allocate memory for kqueue event array");
+        rc = SOCKPERF_ERR_NO_MEMORY;
+    } else if (!mp_kqueue_changes) {
+        log_err("Failed to allocate memory for kqueue change array");
+        rc = SOCKPERF_ERR_NO_MEMORY;
+    } else {
+        printf("\n");
+        m_max_events = 0;
+        m_kqfd = kqueue();
+        if (m_kqfd == -1){
+            log_err("Failed to create kqueue");
+            rc = SOCKPERF_ERR_FATAL;
+        } else {
+            for (int ifd = m_fd_min; ifd <= m_fd_max; ifd++) {
+                if (g_fds_array[ifd]) {
+                    print_addresses(g_fds_array[ifd], list_count);
+                    EV_SET(&mp_kqueue_changes[m_max_events], ifd, EVFILT_READ, EV_ADD | EV_OOBAND, 0, 0, 0);
+                    m_max_events++;
+                }
+            }
+            int success = kevent(m_kqfd, mp_kqueue_changes, m_max_events, NULL, 0, NULL);
+            if (success == -1){
+                rc = SOCKPERF_ERR_FATAL;
+            }
+        } 
+    }
+
+    return rc;
+}
+#endif // defined(__FreeBSD__) || defined(__APPLE__)
 #ifdef USING_VMA_EXTRA_API // VMA socketxtreme-extra-api Only
 //==============================================================================
 //------------------------------------------------------------------------------
diff --git a/src/iohandlers.h b/src/iohandlers.h
index ce94e86..312b38a 100644
--- a/src/iohandlers.h
+++ b/src/iohandlers.h
@@ -378,7 +378,80 @@ private:
     int m_max_events;
 };
 #endif // !defined(__FreeBSD__) && !defined(__APPLE__) 
+#if defined(__FreeBSD__) || defined(__APPLE__) 
+//==============================================================================
+class IoKqueue : public IoHandler {
+public:
+    IoKqueue(int _fd_min, int _fd_max, int _fd_num);
+    virtual ~IoKqueue();
+
+    //------------------------------------------------------------------------------
+    inline void update() {
+        int ifd = 0;
+        int change_num = 0;
+        int rc = 0;
+
+        m_look_start = 0;
+        m_look_end = m_fd_num;
+        m_max_events = m_fd_num;
+        for (ifd = m_fd_min; ifd <= m_fd_max; ifd++) {
+            if (g_fds_array[ifd]) {
+                int i = 0;
+                int active_fd_count = g_fds_array[ifd]->active_fd_count;
+                int *active_fd_list = g_fds_array[ifd]->active_fd_list;
+
+                assert(active_fd_list && "corrupted fds_data object");
 
+                while (active_fd_count) {
+                    /* process active sockets in case TCP (listen sockets are set in
+                     * prepareNetwork()) and
+                     * skip active socket in case UDP (it is the same with set in prepareNetwork())
+                     */
+                    if (active_fd_list[i] != (int)INVALID_SOCKET) {
+                        if (active_fd_list[i] != ifd) {
+                            EV_SET(&mp_kqueue_changes[change_num], active_fd_list[i], EVFILT_READ, EV_ADD | EV_OOBAND, 0, 0, 0);
+                            change_num++;
+                            m_max_events++;
+                        }
+                        active_fd_count--;
+                    }
+                    i++;
+
+                    assert((i < MAX_ACTIVE_FD_NUM) &&
+                           "maximum number of active connection to the single TCP addr:port");
+                    assert(m_max_events < MAX_FDS_NUM);
+                }
+            }
+        }
+        rc = kevent(m_kqfd, mp_kqueue_changes, change_num, NULL, 0, NULL);
+        assert(rc != -1);
+        /* It can be omitted */
+        m_look_end = m_max_events;
+    }
+
+    //------------------------------------------------------------------------------
+    inline int waitArrival() {
+        m_look_end = kevent(m_kqfd, NULL, 0, mp_kqueue_events, m_max_events, mp_timeout);
+        return m_look_end;
+    }
+    //------------------------------------------------------------------------------
+    inline int analyzeArrival(int ifd) const {
+        assert((ifd < MAX_FDS_NUM) && "exceeded tool limitation (MAX_FDS_NUM)");
+
+        return mp_kqueue_events[ifd].ident;
+    }
+
+    virtual int prepareNetwork();
+
+private:
+    const struct timespec m_timeout;
+    const struct timespec* mp_timeout;
+    struct kevent *mp_kqueue_events;
+    struct kevent *mp_kqueue_changes;
+    int m_kqfd;
+    int m_max_events;
+};
+#endif // defined(__FreeBSD__) || defined(__APPLE__) 
 #ifdef USING_VMA_EXTRA_API // VMA socketxtreme-extra-api Only
 //==============================================================================
 class IoSocketxtreme : public IoHandler {
-- 
2.43.0

